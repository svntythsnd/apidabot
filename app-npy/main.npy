// v3.12

import time;
import datetime;
import requests;
import io;

import discord;
import json;
import re;

from discord.ext import commands, tasks;
from os import chdir;

chdir('./app');

class InfoMsg {
    permission_error = 'Interaction failed - you might not have the required permissions';
    setup_error = 'This server does not have verification setup.';
    member_presence_error = 'User is not on this server!';
    member_already_verified_error = 'User is already verified!';
    member_unverifiable_error = 'User is not manually verifiable!';
    verification_success = ;=id: f'<@{id}> has been verified!';
    verification_decline_success = ;=user: f'<@{user.id}> has been rejected and kicked!';
    verification_decline_audit =;=context: f'Verification attempt was declined by admin <@{context.author.id}>';
    verification_period_expiration_audit = 'Verification period expired';
    manual_verification_period_expiration_audit = 'Manual verification period expired';
    verification_denied = 'Your verification request was denied by the system. You may have already submitted your request';
    verification_accepted = 'Your verification request has been submitted!';
    verification_confirm_success = ;=user: f'<@{user.id}> has been verified!';
    verification_confirm_audit =;=context: f'User verified by admin <@{context.author.id}>';
    verification_role_on_join_audit = 'Unverified role given to new member';
    set_unverified_role = ;=id: f'Unverified role set to <@&{id}>';
    set_v_timeout = ;=seconds: f'Verification timeout interval set to {datetime.timedelta(seconds=seconds)}';
    set_mv_timeout = ;=seconds: f'Manual verification timeout interval set to {datetime.timedelta(seconds=seconds)}';
    set_v_message = ;=json: f'Verification message set to:\n```json\n{json}```';
    set_vlog_message = ;=json: f'Verification log message template set to:\n```json\n{json}```';
    set_vlog_channel = ;=id: f'Verification log channel set to <#{id}>'
}

path = 'external.json';
token = open('D:/slycefolder/ins/pnx/apd', 'r').read();

:= jsonPrettify(jsonStr, sort_keys: bool = False, indent: int = 4) {
    => json.dumps(safeload(jsonStr),sort_keys=sort_keys, indent=indent)
}

class TimeUnits {
    second = 1;
    minute = 60*second;
    hour = 60*minute;
    day = 24*hour;
    week = 7*day;
    unit_dict = -{'s': second, 'm': minute, 'h': hour, 'd': day, 'w': week}-;
    unit_map = ;=unit: TimeUnits.unit_dict.get(unit)
}

intents = discord.Intents(
        message_content = True,
        guilds = True,
        members = True,
    );

/*:= safeload(string) {
    try: out = json.loads(string);
    except json.JSONDecodeError as e {
        print(e);
        out = -{}-
    }
    => out
}*/

:= safeload(string) {
    try :=> json.loads(string);
    except json.JSONDecodeError :=> -{}-
}

:= filter_none(dt) {
    filtered_dt = -{}-;
    for k, v -> dt.items() {
        if any([
            v -> [[],-{}-,None,''],
            (k -> ['mention_author']) == v
            ]): continue;
        if isinstance(v, dict): v = filter_none(v);
        elif isinstance(v, list): v = [filter_none(e) for e -> v];
        filtered_dt.update(-{k: v}-)
    } => filtered_dt
}

class theClient(commands.Bot) {
  := __init__(self) {
    super().__init__(intents=intents);
    self.synced = False;
    // self.remove_command('help')
  }

  async := on_ready(self) {
    await self.wait_until_ready();
    print(f'We have logged in as {self.application_id}');
    // print('\n'.join([f"{(guild <- self.get_guild(gid)).name}:\n{',\n'.join(str(e) for e -> await guild.invites())}" for gid -> ext.guilds.getids()]));
    usercheck_task.start()
  }

  async := usercheck(self) {
      newguilds = -{}-;
      for gid -> ext.guilds.getids() {
        guild = ext.guilds.getg(gid);
        rguild = self.get_guild(gid);
        new_verif_pending = [];
        if verifcheck(rguild) {
          for user -> guild.verif_pending {
            if ruser <- rguild.get_member(user.id) {
              if time.time() - user.created_at < guild.verif_timeout {
                new_verif_pending.append(user)
              } else {
                await rguild.kick(ruser, reason=InfoMsg.verification_period_expiration_audit)
              }
            }
          }
        }
        guild.verif_pending = new_verif_pending;
        new_verif_admin_pending = [];
        if verifcheck(rguild) {
          for user -> guild.verif_admin_pending {
            if ruser <- rguild.get_member(user.id) {
              if time.time() - user.created_at < guild.verif_admin_timeout {
                new_verif_admin_pending.append(user)
              } else {
                await rguild.kick(ruser, reason=InfoMsg.manual_verification_period_expiration_audit)
              }
            }
          }
        }
        guild.verif_admin_pending = new_verif_admin_pending;

        newguilds.update(-{str(gid): guild.dictify()}-)
      }

      ext.guilds = GuildCache(newguilds)
  }
}


:= getDefault(dct, key, default) {
    try :=> dct[key];
    except KeyError :=> default
}

class Ext {

    @property;
    := guilds(self) {
        with open(path, 'r') as f :=> GuildCache(getDefault(safeload(f.read()), 'guilds', -{}-))
    }

    @guilds.setter;
    := guilds(self, new) {
        with open(path, 'r') as f {
            extDict = safeload(/*a if (a <- */f.read()/*) != '' else '{}'*/);
            extDict.update(-{'guilds': new.getall()}-)
        } with open(path, 'w') as f: f.write(json.dumps(extDict, indent=4)) // indent not necessary
    }

 /* @property;
    := help_message(self) {
        with open(path, 'r') as f {
            => ComplexMessage(message=Message.from_dict(getDefault(safeload(f.read()), 'help_message', -{}-)))
        }
    }
 */
}

class GuildCache {
    := __init__(self, v: dict): self._v = -{i: CachedGuild(i, v[i]) for i -> v}-;

    := getg(self, id) :=> getDefault(self._v, str(id), CachedGuild(id, -{}-));

    := getall(self) {
        out = -{}-;
        for e -> self._v: out.update(-{e: self._v[e].dictify()}-);
        => out
    }

    := getids(self) :=> [int(e) for e -> self._v];

    := setg(self, id, value): self._v.update(-{str(id): value}-);

    := addg(self, value): self._v.update(-{str(value.id): value}-);

    := remg(self, id) {
        try: self._v.pop(str(id));
        except KeyError {}
    }
}

class CachedGuild {
    := __init__(self, id, jsonDict=None) {
        if jsonDict =& None: jsonDict = -{}-;
        self.id = id;
        self.verif_role = jsonDict.get('verif_role');
        self.verif_msg = Message.from_dict(getDefault(jsonDict, 'verif_msg', -{}-));
        self.verif_log_msg = Message.from_dict(getDefault(jsonDict, 'verif_log_msg', -{}-));
        self.verif_log_channel = jsonDict.get('verif_log_channel');
        self.verif_timeout = getDefault(jsonDict, 'verif_timeout', TimeUnits.hour);
        self.verif_admin_timeout = getDefault(jsonDict, 'verif_admin_timeout', 2*TimeUnits.day);
        self.verif_pending = [UserCache.from_dict(e) for e -> getDefault(jsonDict, 'verif_pending', [])];
        self.verif_admin_pending = [UserCache.from_dict(e) for e -> getDefault(jsonDict, 'verif_admin_pending', [])]
    }

    := verif_msg_from_dict(self, verif_msg): self.verif_msg = Message.from_dict(verif_msg);

    := verif_log_msg_from_dict(self, verif_log_msg): self.verif_log_msg = Message.from_dict(verif_log_msg);

    := dictify(self, shorten=True) {
        dictified = -{
                'verif_role': self.verif_role,
                'verif_msg': self.verif_msg.dictify(),
                'verif_log_msg': self.verif_log_msg.dictify(),
                'verif_log_channel': self.verif_log_channel,
                'verif_timeout': self.verif_timeout,
                'verif_admin_timeout': self.verif_admin_timeout,
                'verif_pending': [e.dictify() for e -> self.verif_pending],
                'verif_admin_pending': [e.dictify() for e -> self.verif_admin_pending]
            }-;
        if shorten: dictified = filter_none(dictified);
        => dictified
    }
}

class UserCache {
    := __init__(self, id, created_at=None) {
        self.id = id;
        self.created_at = created_at if created_at !=& None else time.time()
    }

    @classmethod;
    := from_dict(cls, jsonDict) {
        id = jsonDict.get('id');
        created_at = jsonDict.get('created_at');
        => cls(id, created_at)
    }

    := dictify(self) :=> -{
                'id': self.id,
                'created_at':  self.created_at
            }-
}

class Message {
    := __init__(self, content='', embeds=None, files=None, delete_after=None, reference=None, poll=None, stickers=None, silent=False, mention_author=True, ephemeral=False, tts=False, view=None) {
        for x -> embeds, files, stickers {
            if x =& None: x = []
        }
        self.content = content;
        self.embeds = embeds;
        self.files = files;
        self.delete_after = delete_after;
        self.reference = reference;
        self.poll = poll;
        self.stickers = stickers;
        self.silent = silent;
        self.mention_author = mention_author;
        self.ephemeral = ephemeral;
        self.tts = tts;
        self.view = view;
    }

    := adapted_files(self, ctx) {
        if self.files !=& None && isFilesAuth(ctx) :=> [e for e, u -> self.files];
        => None
    }

    @classmethod;
    := from_dict(cls, jsonDict) {
        content = getDefault(jsonDict, 'content', '');
        embedDict = getDefault(jsonDict, 'embeds', []);
        for e -> embedDict {
            if (f <- e.get("color")) !=& None && f.__class__ != int: e.update(-{"color": int(f, 0)}-)
        }
        embeds = [discord.Embed.from_dict(e) for e -> embedDict];
        /*files = [];
        for e -> getDefault(jsonDict, 'files', []) {
            with open(getDefault(e, 'url', None), 'rb') as file:
                files += discord.File(
                    file.read(),
                    description=getDefault(e, 'description', None),
                    spoiler=getDefault(e, 'spoiler', False)
                )
        }*/
        files = [
            (
                discord.File(
                    io.BytesIO(requests.get(url <- getDefault(e, 'url', None)).content),
                    filename=getDefault(e, 'filename', None),
                    description=getDefault(e, 'description', None),
                    spoiler=getDefault(e, 'spoiler', False)
                ),
                url
            ) for e -> getDefault(jsonDict, 'files', [])
        ];
        poll = jsonDict.get('poll');
        if poll !=& None: poll = discord.Poll(poll.get('question'), answers=[
                discord.PollAnswer(e.get('text'),
                emoji=(
                    discord.PartialEmoji.from_str(emoji)
                    if (emoji <- e.get('emoji')) !=& None else None
                    )
                ) for e -> poll.get('answers')
            ],
            duration=poll.get('duration'),
            allow_multiselect=getDefault(poll, 'allow_multiselect', False)
            );
        stickers = getDefault(jsonDict, 'stickers', []);
        delete_after = jsonDict.get('delete_after');
        reference = jsonDict.get('reference');
        silent = getDefault(jsonDict, 'silent', False);
        mention_author = getDefault(jsonDict, 'mention_author', True);
        ephemeral = getDefault(jsonDict, 'ephemeral', False);
        tts = getDefault(jsonDict, 'tts', False);

        => cls(content, embeds, files, delete_after, reference, poll, stickers, silent, mention_author, ephemeral, tts)
    }

    := set_view(self, view) {
        self.view = view;
        => self
    }

    := dictify(self, shorten=True) {
        embedList = [e.to_dict() for e -> self.embeds];
        for e -> embedList {
            if (f <- e.get("color")) !=& None: e.update(-{"color": hex(f)}-)
        }
        dictified = -{
                'content': self.content,
                'embeds': embedList,
                'files': [
                    -{
                        "url": u,
                        "filename": e.filename,
                        "description": e.description,
                        "spoiler": e.spoiler
                    }- for e, u -> self.files
                ],
                'poll':  -{
                    "duration": poll.duration,
                    "allow_multiselect": poll.allow_multiselect,
                    "question": poll.question.text,
                    "answers": [
                        -{
                            "emoji": str(emoji) if (emoji <- e.media.emoji) !=& None else None,
                            "text": str(e.media.text)
                            //"voters": [u.id for u -> await e.voters()]
                        }- for e -> poll.answers
                    ]
                }- if (poll <- self.poll) !=& None else None,
                'stickers': self.stickers,
                'delete_after': self.delete_after,
                'reference': self.reference,
                'silent': self.silent,
                'mention_author': self.mention_author,
                'ephemeral': self.ephemeral,
                'tts': self.tts
            }-;
        if shorten: dictified = filter_none(dictified);
        => dictified
    }

    async := send(self, ctx, *, respond=False) {
        if isAuth(ctx) || respond {
            content = self.content;
            embeds = self.embeds;
            files = self.adapted_files(ctx);
            delete_after = self.delete_after;
            reference = (
                await ctx.channel.fetch_message(
                    /* ctx.interaction.id #
                    if r <= 0 #
                    else */r
                )
                if (r <- self.reference) !=& None #
                else None
            );
            poll = self.poll if isPollsAuth(ctx) else None;
            silent = self.silent;
            mention_author = self.mention_author;
            ephemeral = self.ephemeral;
            tts = self.tts if isTTSAuth(ctx) else False;
            stickers = [await bot.fetch_sticker(e) for e -> stickers] if (stickers <- self.stickers) !=& None else None;
            view = self.view;
            return_message = await ctx.respond(
                content=content,
                embeds=embeds,
                files=files,
                delete_after=delete_after,
                poll=poll,
                ephemeral=ephemeral,
                tts=tts,
                view=view
            ) if respond else await ctx.send(
                content=content,
                embeds=embeds,
                files=files,
                delete_after=delete_after,
                reference=reference,
                poll=poll,
                silent=silent,
                mention_author=mention_author,
                tts=tts,
                stickers=stickers,
                view=view
            );
            => return_message
        } await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
    }

    async := respond(self, ctx) :=> await self.send(ctx, respond=True)
}

ext = Ext();

bot = theClient();

@tasks.loop(seconds=5);
async := usercheck_task():
    await bot.usercheck();

:= isAuth(ctx) {
    if isinstance(ctx, commands.Context) :=> !isinstance(ctx.channel, discord.abc.GuildChannel) || ctx.author.guild_permissions.manage_webhooks;
    => True
}

isVerAuth = ;=ctx:
    ctx.author.guild_permissions.manage_guild;

isPinAuth = ;=ctx:
    ctx.author.guild_permissions.manage_messages;

isReactAuth = ;=ctx:
    ctx.author.guild_permissions.add_reactions;

isInteractionVerAuth = ;=interaction:
    interaction.user.guild_permissions.manage_guild;

:= isTTSAuth(ctx) {
    if isinstance(ctx, commands.Context) :=> !isinstance(ctx.channel, discord.abc.GuildChannel) || ctx.author.guild_permissions.send_tts_messages;
    => True
}

:= isFilesAuth(ctx) {
    if isinstance(ctx, commands.Context) :=> !isinstance(ctx.channel, discord.abc.GuildChannel) || ctx.author.guild_permissions.attach_files;
    => True
}

:= isPollsAuth(ctx) {
    if isinstance(ctx, commands.Context) :=> !isinstance(ctx.channel, discord.abc.GuildChannel) || ctx.author.guild_permissions.send_polls;
    => True
}

messagesGroup = bot.create_group("wh", "Sending webhook-style messages");
messagesResponseGroup = bot.create_group("r", "Sending response messages");
utilityGroup = bot.create_group("u", "Various QOL commands");


async := embed(ctx, message) {
    try {
        await Message.from_dict(safeload(message)).send(ctx);
        await Message('Message sent!', ephemeral=True, delete_after=5.0).respond(ctx);
        =>
    } except {}
    await Message('Message failed to send!', ephemeral=True).respond(ctx)
}

async := rembed(ctx, message) {
    try {
        message = Message.from_dict(safeload(message));
        message.poll = None;
        await message.respond(ctx);
        =>
    } except {}
    await Message('Message failed to send!', ephemeral=True).respond(ctx)
}

@messagesGroup.command(name = "embed", description = "Send a message based on a json string");
async := embedstr(ctx, *, message: str):
    await embed(ctx, message);

@messagesGroup.command(name = "file-embed", description = "Send a message based on a json file");
async := embedf(ctx, *, json_file: discord.Attachment):
    await embed(ctx, await json_file.read());

@messagesGroup.command(name = "say", description = "Say something");
async := say(ctx, *, message: str) {
    message = message.replace('\\\\n', '\\n').replace('\\n', '\n');
    await embed(ctx, f'{{"content":"{message}"}}')
}

@messagesGroup.command(name = "closepoll", description = "Close a poll");
async := closepoll(ctx, *, message_id: str) {
    try {
        assert isAuth(ctx);
        await (await ctx.fetch_message(message_id)).end_poll();
        await Message('Poll closed!', ephemeral=True).respond(ctx);
        =>
    } except {}
    await Message('Poll closing failed!', ephemeral=True).respond(ctx)
}

@messagesGroup.command(name = "pin", description = "Pin a message");
async := pin(ctx, *, message_id: str, reason:str=None) {
    try {
        assert isPinAuth(ctx);
        assert isAuth(ctx);
        await (await ctx.fetch_message(message_id)).pin(reason=reason);
        await Message('Message pinned!', ephemeral=True).respond(ctx);
        =>
    } except {}
    await Message('Message pinning failed!', ephemeral=True).respond(ctx)
}

@messagesGroup.command(name = "unpin", description = "Unpin a message");
async := pin(ctx, *, message_id: str, reason:str=None) {
    try {
        assert isPinAuth(ctx);
        assert isAuth(ctx);
        await (await ctx.fetch_message(message_id)).unpin(reason=reason);
        await Message('Message unpinned!', ephemeral=True).respond(ctx);
        =>
    } except {}
    await Message('Message unpinning failed!', ephemeral=True).respond(ctx)
}

@messagesGroup.command(name = "react", description = "React to a message");
async := react(ctx, *, message_id: str, emoji: str) {
    try {
        assert isAuth(ctx);
        await (await ctx.fetch_message(message_id)).add_reaction(discord.PartialEmoji.from_str(emoji));
        await Message('Reaction added!', ephemeral=True).respond(ctx);
        =>
    } except {}
    await Message('Reaction failed!', ephemeral=True).respond(ctx)
}

@messagesResponseGroup.command(name = "embed", description = "Respond with a message based on a json string");
async := rembedstr(ctx, *, message: str):
    await rembed(ctx, message);

@messagesResponseGroup.command(name = "file-embed", description = "Respond with a message based on a json file");
async := rembedf(ctx, *, json_file: discord.Attachment):
    await rembed(ctx, await json_file.read());

@messagesResponseGroup.command(name = "say", description = "Respond by saying something");
async := rsay(ctx, *, message: str):
    await Message(message.replace('\\\\n', '\\n').replace('\\n', '\n')).respond(ctx);

@messagesResponseGroup.command(name = "delete", description = "Deletes a message");
async := delete(ctx, *, message_id: str) {
    try {
        reference_message = await ctx.fetch_message(message_id);
        if isAuth(ctx) || reference_message.interaction.user.id == ctx.author.id {
            await reference_message.delete();
            await Message('Message deleted successfully!', ephemeral=True).respond(ctx);
            =>
        }
    } except discord.HTTPException {}
    await Message('Message delete failed!', ephemeral=True).respond(ctx)
}

@utilityGroup.command(name = "codeblock", description = "Converts message to a codeblock");
async := codeblock(ctx, message) {
    await Message(f'```{message}```', ephemeral=True).respond(ctx)
}

@utilityGroup.command(name = "buzz", description="Sends the bot's latency.");
async := ping(ctx) {
    await Message(f'Buzz! Latency is `{bot.latency}`', ephemeral=True).respond(ctx)
}

@utilityGroup.command(name = "newlinify", description = "Turn newlines into \\n");
async := newlinify(ctx, *, message_id: str) {
    try {
        reference_message = await ctx.fetch_message(message_id);
        if reference_message.content != '' {
            await Message(reference_message.content.replace('\\n', '\\\\n').replace('\n','\\n'), ephemeral=True).respond(ctx);
            =>
        }
    } except discord.HTTPException {}
    await Message('Newlinification failed!', ephemeral=True).respond(ctx)
}

:= nativeMessageDictify(message, shorten=True) {
    embeds = [e.to_dict() for e -> message.embeds];
    for e -> embeds {
        if (f <- e.get("color")) !=& None: e.update( -{"color": hex(f)}- )
    }

    dictified = -{
            "content": message.content,
            "embeds": embeds,
            "files": [
                -{
                    "url": e.url,
                    "filename": e.filename,
                    "description": e.description,
                    "spoiler": e.is_spoiler()
                }- for e -> message.attachments
            ],
            "reactions": [
                -{
                    "emoji": str(e.emoji),
                    // "users": [u.id for u -> e.users()],
                    "burst": e.me_burst,
                    "count": e.count
                }- for e -> message.reactions
            ],
            "poll": -{
                "duration": poll.duration,
                "allow_multiselect": poll.allow_multiselect,
                "question": poll.question.text,
                "answers": [
                    -{
                        "emoji": str(emoji) if (emoji <- e.media.emoji) !=& None else None,
                        "text": str(e.media.text),
                        "count": e.count
                        //"voters": [u.id for u -> e.voters()]
                    }- for e -> poll.answers
                ]
            }- if (poll <- message.poll) !=& None else None,
            "stickers": [e.id for e -> message.stickers],
            "reference": message.reference.message_id if message.reference !=& None else None,
            "tts": message.tts,
            "created_at": datetime.datetime.timestamp(message.created_at),
            "edited_at": datetime.datetime.timestamp(message.edited_at) if message.edited_at !=& None else None
        }-;
    if shorten: dictified = filter_none(dictified);
    => dictified
}

@utilityGroup.command(name = "jsonify", description = "Turn a message into json");
async := jsonify(ctx, *, message_id: str) {
    try {
        if reference_message <- await ctx.fetch_message(message_id) {
            await Message.from_dict(-{ "embeds": [ -{ "description": f"```json\n{json.dumps(nativeMessageDictify(reference_message), indent=4)}\n```"}- ], "ephemeral": True }-).respond(ctx);
            =>
        }
    } except discord.HTTPException {}
    await Message('Jsonification failed!', ephemeral=True).respond(ctx)
}

:= verifcheck(rguild) :=> (
        (guild <- ext.guilds.getg(rguild.id)).verif_admin_timeout !=& None)
        && (guild.verif_timeout !=& None)
        && (guild.verif_role !=& None)
        && (guild.verif_log_channel !=& None
    );

verificationGroup = bot.create_group("v", "Various verification-related commands");
verificationGroup.contexts = [discord.InteractionContextType.guild];
@verificationGroup.command(name = "verify", description="Verifies you if you are unverified");
async := verify(ctx) {
    try {
        assert verifcheck(ctx.guild);
        guild = ext.guilds.getg(ctx.guild.id);
        if any(e.id == ctx.author.id for e -> guild.verif_pending) && !any(e.id == ctx.author.id for e -> guild.verif_admin_pending) {
            await Message(InfoMsg.verification_accepted, ephemeral=True).respond(ctx);
            guilds = ext.guilds;
            guild.verif_pending = [e for e -> guild.verif_pending if e.id != ctx.user.id];
            guild.verif_admin_pending.append(UserCache(ctx.user.id));
            guilds.addg(guild);
            await manualVerificationMessage(ctx.user, guild).send(ctx.guild.get_channel(guild.verif_log_channel));
            ext.guilds = guilds;
            =>
        }
    } except AssertionError {
        await Message(InfoMsg.setup_error, ephemeral=True).respond(ctx)
    } except {
        await Message(InfoMsg.verification_denied, ephemeral=True, delete_after=3.0).respond(ctx)
    }
}

@verificationGroup.command(name = "unvrole", description="Sets the unverified role");
async := unverified_role(ctx, *, role: discord.Role) {
    try {
        if isVerAuth(ctx) {
            await Message(InfoMsg.set_unverified_role(role.id), delete_after=15.0).respond(ctx);
            guilds = ext.guilds;
            guild = guilds.getg(ctx.guild.id);
            guild.verif_role = role.id;
            guilds.addg(guild);
            ext.guilds = guilds;
            =>
        }
    } except {}
    await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "timeout", description="Sets the verification timeout");
async := timeout(ctx, *, amt: float, time_interval: discord.Option(str, choices=['s', 'm', 'h', 'd', 'w'])) {
    try {
        if isVerAuth(ctx) {
            seconds = float(amt*TimeUnits.unit_map(time_interval));
            await Message(InfoMsg.set_v_timeout(seconds), delete_after=15.0).respond(ctx);
            guilds = ext.guilds;
            guild = guilds.getg(ctx.guild.id);
            guild.verif_timeout = seconds;
            guilds.addg(guild);
            ext.guilds = guilds;
            =>
        }
    } except {}
    await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "mtimeout", description="Sets the manual verification timeout");
async := admin_timeout(ctx, *, amt: discord.SlashCommandOptionType.number, time_interval: discord.Option(str, choices=['s', 'm', 'h', 'd', 'w'])) {
    try {
        if isVerAuth(ctx) {
            seconds = float(amt*TimeUnits.unit_map(time_interval));
            await Message(InfoMsg.set_mv_timeout(seconds), delete_after=15.0).respond(ctx);
            guilds = ext.guilds;
            guild = guilds.getg(ctx.guild.id);
            guild.verif_admin_timeout = amt*TimeUnits.unit_map(time_interval);
            guilds.addg(guild);
            ext.guilds = guilds;
            =>
        }
    } except {}
    await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "msg", description="Sets the verification message");
async := set_verif_msg(ctx, *, message: str) {
    try {
        if isVerAuth(ctx) {
            await Message(InfoMsg.set_v_message(jsonPrettify(message)), delete_after=15.0).respond(ctx);
            guilds = ext.guilds;
            guild = guilds.getg(ctx.guild.id);
            guild.verif_msg_from_dict(safeload(message));
            guilds.addg(guild);
            ext.guilds = guilds;
            =>
        }
    } except {}
    await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "logmsg", description="Sets the verif-log message template (_ _user_ _ - mention, _ _username_ _ - username, _ _id_ _ - id)");
async := set_verif_log_msg(ctx, *, message: str) {
    try {
        if isVerAuth(ctx) {
            await Message(InfoMsg.set_vlog_message(jsonPrettify(message)), delete_after=15.0).respond(ctx);
            guilds = ext.guilds;
            guild = guilds.getg(ctx.guild.id);
            guild.verif_log_msg_from_dict(safeload(message));
            guilds.addg(guild);
            ext.guilds = guilds;
            =>
        }
    } except {}
    await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "logchannel", description="Sets the verif-log channel");
async := set_verif_log_channel(ctx, *, channel: discord.TextChannel) {
    try {
        if isVerAuth(ctx) {
            await Message(InfoMsg.set_vlog_channel(channel.id), delete_after=15.0).respond(ctx);
            guilds = ext.guilds;
            guild = guilds.getg(ctx.guild.id);
            guild.verif_log_channel = channel.id;
            guilds.addg(guild);
            ext.guilds = guilds;
            =>
        }
    } except {}
    await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "get", description="Sends the current verification config");
async := config_get(ctx) {
    try {
        if isVerAuth(ctx) {
            guild = ext.guilds.getg(ctx.guild.id);
            await Message(
                f'## CONFIG FOR CURRENT GUILD\n\
                 \\> Unverified role set to <@&{guild.verif_role}>\n\
                 \\> Verification timeout set to {datetime.timedelta(seconds=guild.verif_timeout)}\n\
                 \\> Manual verification timeout set to {datetime.timedelta(seconds=guild.verif_admin_timeout)}\n\
                 \\> Verification message set to:\n\
                 ```json\n{json.dumps(guild.verif_msg.dictify(), indent=4)}```\n\
                 \\> Verification log message template set to:\n\
                 ```json\n{json.dumps(guild.verif_log_msg.dictify(shorten=True), indent=4)}```\n\
                 \\> Verification log channel set to <#{guild.verif_log_channel}>.',
                 ephemeral=True
            ).respond(ctx);
            =>
        }
    } except {}
    await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

class manualVerificationView(discord.ui.View) {
    id_get =;= i: int(re.search(r'((?<=<@)\d*(?=>))', i.message.embeds[~0].footer.text).group(0));
    @discord.ui.button(label="Verify", style=discord.ButtonStyle.success, emoji='\u2714\uFE0F');
    async := verify_callback(self, button, interaction) {
        if isInteractionVerAuth(interaction) {
            id = manualVerificationView.id_get(interaction);
            guilds = ext.guilds;
            guild_cache = guilds.getg((guild <- interaction.guild).id);
            guild_cache.verif_admin_pending = [e for e -> guild_cache.verif_admin_pending if e.id != id];
            await guild.get_member(id).remove_roles(guild.get_role(guild_cache.verif_role), reason='Verification complete');
            guilds.addg(guild_cache);
            ext.guilds = guilds;
            await Message(InfoMsg.verification_success(id)).respond(interaction)
        } await Message(InfoMsg.permission_error, ephemeral=True).respond(interaction)
    }
    @discord.ui.button(label="Reject", style=discord.ButtonStyle.danger, emoji='\u274C');
    async := reject_callback(self, button, interaction) {
        if isInteractionVerAuth(interaction) {
            id = manualVerificationView.id_get(interaction);
            await (guild <- interaction.guild).kick(guild.get_member(id), reason=InfoMsg.verification_declined_audit);
            await Message(InfoMsg.verification_declined_success(id)).respond(interaction)
        } await Message(InfoMsg.permission_error, ephemeral=True).respond(interaction)
    }
}

username_display =;= user: f'{user.name}{f"#{user.discriminator}" if user.discriminator != "0" else ""}';

:= manualVerificationMessage(user, guild_cache)  {
    msg = json.dumps(guild_cache.verif_log_msg.dictify()).replace('_ _user_ _', f'<@{user.id}>').replace('_ _username_ _', username_display(user)).replace('_ _id_ _', str(user.id));
    msg = safeload(msg);
    embeds = getDefault(msg, 'embeds', []);
    embeds.append(-{'footer': -{ 'text': f'>> <@{user.id}> | {username_display(user)}', 'icon_url': user.avatar.url }- }-);
    msg.update(-{'embeds': embeds}-);
    => Message.from_dict(msg)
}

/* class verificationView(discord.ui.View) {
    @discord.ui.button(label="Verify!", style=discord.ButtonStyle.success, emoji='\uD83D\uDC4C');
    async := button_callback(self, button, interaction) {
      guild = ext.guilds.getg(id <- interaction.guild_id);
      if any(e.id == interaction.user.id for e -> guild.verif_pending) && !any(e.id == interaction.user.id for e -> guild.verif_admin_pending) {
        await interaction.response.send_message("Your verification request has been submitted!", ephemeral=True);
        guilds = ext.guilds;
        // guild = guilds.getg(id <- interaction.guild_id);
        guild.verif_pending = [e for e -> guild.verif_pending if e.id != interaction.user.id];
        guild.verif_admin_pending.append(UserCache(interaction.user.id));
        guilds.setg(id, guild);
        await manualVerificationMessage(interaction.user, guild).send(interaction.guild.get_channel(guild.verif_log_channel));
        ext.guilds = guilds
      } else { await interaction.response.send_message("Your verification request was denied by the system. You may have already submitted your request", ephemeral=True, delete_after=3.0) }
    }
} */

@verificationGroup.command(name = "sendverif", description="Sends the predefined verification message");
async := send_verification(ctx) {
    if isVerAuth(ctx) {
        await ext.guilds.getg(ctx.guild.id).verif_msg.respond(ctx);
        =>
    } await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}

// @verificationGroup.command(name = "forceverif", description="Forces a user to be verified");
/* async := force_verification(ctx, user: discord.Member) {
    if isVerAuth(ctx) {
        guilds = ext.guilds;
        try: guild_cache = guilds.getg(ctx.guild.id);
        except AttributeError {
          await Message(InfoMsg.member_presence_error, ephemeral=True).respond(ctx);
          =>
        }
        guild_cache.verif_admin_pending = [e for e -> guild_cache.verif_admin_pending if e.id != user.id];
        guild_cache.verif_pending = [e for e -> guild_cache.verif_pending if e.id != user.id];
        await user.remove_roles(ctx.guild.get_role(guild_cache.verif_role), reason=InfoMsg.verification_success_audit(ctx));
        guilds.addg(guild_cache);
        ext.guilds = guilds;
        await Message(InfoMsg.force_verification_success(user.id)).respond(ctx);
        =>
    } await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
}*/

@verificationGroup.command(name = "confirm", description="Verifies a user");
async := confirm(ctx, user: discord.Member) {
    try {
        assert verifcheck(ctx.guild);
        if isVerAuth(ctx) {
            guilds = ext.guilds;
            try: guild_cache = guilds.getg(ctx.guild.id);
            except AttributeError {
              await Message(InfoMsg.member_presence_error, ephemeral=True).respond(ctx);
              =>
            }
            if !((user.id -> [e.id for e -> guild_cache.verif_pending]) || (user.id -> [e.id for e -> guild_cache.verif_admin_pending])) {
                await Message(InfoMsg.member_already_verified_error, ephemeral=True).respond(ctx);
                =>
            }
            guild_cache.verif_admin_pending = [e for e -> guild_cache.verif_admin_pending if e.id != user.id];
            guild_cache.verif_pending = [e for e -> guild_cache.verif_pending if e.id != user.id];
            await user.remove_roles(ctx.guild.get_role(guild_cache.verif_role), reason=InfoMsg.verification_confirm_audit(ctx));
            guilds.addg(guild_cache);
            ext.guilds = guilds;
            await Message(InfoMsg.verification_confirm_success(user)).respond(ctx);
            await Message(InfoMsg.verification_personal_success(ctx.guild)).respond(ctx)
            =>
        } await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
    } except AssertionError: await Message(InfoMsg.setup_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "decline", description="Kicks an unverified user");
async := decline(ctx, user: discord.Member) {
    try {
        assert verifcheck(ctx.guild);
        if isVerAuth(ctx) {
            guilds = ext.guilds;
            try: guild_cache = guilds.getg(ctx.guild.id);
            except AttributeError {
              await Message(InfoMsg.member_presence_error, ephemeral=True).respond(ctx);
              =>
            }
            if !((user.id -> [e.id for e -> guild_cache.verif_pending]) || (user.id -> [e.id for e -> guild_cache.verif_admin_pending])) {
                await Message(InfoMsg.member_already_verified_error, ephemeral=True).respond(ctx);
                =>
            }
            guild_cache.verif_admin_pending = [e for e -> guild_cache.verif_admin_pending if e.id != user.id];
            guild_cache.verif_pending = [e for e -> guild_cache.verif_pending if e.id != user.id];

            await ctx.guild.kick(user, reason=InfoMsg.verification_decline_audit(ctx));
            guilds.addg(guild_cache);
            ext.guilds = guilds;
            await Message(InfoMsg.verification_decline_success(user)).respond(ctx);
            =>
        } await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
    } except AssertionError: await Message(InfoMsg.setup_error, ephemeral=True).respond(ctx)
}

@verificationGroup.command(name = "veriflist", description="Sends a list of all unverified users");
async := get_veriflist(ctx) {
    try {
        assert verifcheck(ctx.guild);
        if isVerAuth(ctx) {
            guild = ext.guilds.getg(ctx.guild.id);
            if len(guild.verif_pending) > 0 {
                await Message('\n'.join([f'<@{x.id}>, {f"{datetime.timedelta(seconds=guild.verif_timeout)-(datetime.datetime.fromtimestamp(time.time())-datetime.datetime.fromtimestamp(x.created_at))}".split(".", 2)[0]} left (<t:{int(x.created_at + guild.verif_timeout)}:R>)' for x -> guild.verif_pending])).respond(ctx);
                =>
            }
            await Message('There are no unverified users!').respond(ctx);
            =>
        }
    } except AssertionError {
        await Message(InfoMsg.setup_error, ephemeral=True).respond(ctx)
    } except {
        await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
    }
}

@verificationGroup.command(name = "mveriflist", description="Sends a list of all manually unverified users");
async := get_mveriflist(ctx) {
    try {
        assert verifcheck(ctx.guild);
        if isVerAuth(ctx) {
            guild = ext.guilds.getg(ctx.guild.id);
            if len(guild.verif_admin_pending) > 0 {
                await Message('\n'.join([f'<@{x.id}>, {f"{datetime.timedelta(seconds=guild.verif_admin_timeout)-(datetime.datetime.fromtimestamp(time.time())-datetime.datetime.fromtimestamp(x.created_at))}".split(".", 2)[0]} left (<t:{int(x.created_at + guild.verif_admin_timeout)}:R>)' for x -> guild.verif_admin_pending])).respond(ctx);
                =>
            }
            await Message('There are no manually unverified users!').respond(ctx);
            =>
        }
    } except AssertionError {
        await Message(InfoMsg.setup_error, ephemeral=True).respond(ctx)
    } except {
        await Message(InfoMsg.permission_error, ephemeral=True).respond(ctx)
    }
}

@bot.listen();
async := on_guild_join(guild) {
    guilds = ext.guilds;
    guilds.addg(CachedGuild(guild.id));
    ext.guilds = guilds
}

@bot.listen();
async := on_guild_remove(guild) {
    guilds = ext.guilds;
    guilds.remg(guild.id);
    ext.guilds = guilds
}

@bot.listen();
async := on_member_join(member) {
    if verifcheck(member.guild) {
        guilds = ext.guilds;
        guild_cache = guilds.getg((guild <- member.guild).id);
        if !any(e.id == member.id for e -> guild_cache.verif_pending) {
            guild_cache.verif_pending.append(UserCache(member.id));
            guilds.addg(guild_cache);
            ext.guilds = guilds
        }
        await member.add_roles(guild.get_role(ext.guilds.getg(guild.id).verif_role), reason=InfoMsg.verification_role_on_join_audit)
    }
}

@bot.listen();
async := on_member_update(before, user) {
    guilds = ext.guilds;
    guild_cache = guilds.getg((guild <- user.guild).id);
    if !(guild_cache.verif_role -> [role.id for role -> user.roles]) {
        guild_cache.verif_admin_pending = [e for e -> guild_cache.verif_admin_pending if e.id != user.id];
        guild_cache.verif_pending = [e for e -> guild_cache.verif_pending if e.id != user.id];
        // await user.remove_roles(user.guild.get_role(guild_cache.verif_role), reason=InfoMsg.force_verification_success_audit);
        guilds.addg(guild_cache);
        ext.guilds = guilds
    } elif user.id !> [e.id for e -> guild_cache.verif_admin_pending] + [e.id for e -> guild_cache.verif_pending] {
        guild_cache.verif_admin_pending.append(UserCache(user.id));
        guilds.addg(guild_cache);
        ext.guilds = guilds
    }
}

bot.run(token)
